package pubsub

import (
	"fmt"

	"github.com/AsynkronIT/protoactor-go/actor"
	"github.com/dumacp/go-ignition/internal/messages"
	"github.com/dumacp/go-ignition/internal/pubsub"
	svc "github.com/dumacp/go-ignition/internal/services"
	"github.com/dumacp/go-ignition/pkg/services"
	"github.com/dumacp/go-logs/pkg/logs"
)

//Gateway interface
type Gateway interface {
	Receive(ctx actor.Context)
}

type pubsubActor struct {
	svc services.Service
	ctx actor.Context
}

//NewService create Service actor
func NewService(ctx *actor.RootContext) Gateway {
	act := &pubsubActor{svc: svc.GetInstance(ctx)}
	return act
}

func service(ctx actor.Context) {
	pubsub.Subscribe(pubsub.TopicStart, ctx.Self(), func(msg []byte) interface{} {
		return &messages.Start{}
	})
	pubsub.Subscribe(pubsub.TopicStop, ctx.Self(), func(msg []byte) interface{} {
		return &messages.Stop{}
	})
	pubsub.Subscribe(pubsub.TopicStop, ctx.Self(), func(msg []byte) interface{} {
		return &messages.Restart{}
	})
	pubsub.Subscribe(pubsub.TopicStatus, ctx.Self(), func(msg []byte) interface{} {
		req := &messages.StatusRequest{}
		if err := req.Unmarshal(msg); err != nil {
			logs.LogWarn.Println(err)
			return nil
		}
		return req
	})
}

//Receive function
func (act *pubsubActor) Receive(ctx actor.Context) {
	act.ctx = ctx
	switch msg := ctx.Message().(type) {
	case *messages.Start:
		act.svc.Start()
	case *messages.Stop:
		act.svc.Stop()
	case *messages.Restart:
		act.svc.Restart()
	case *messages.StatusRequest:
		resp := act.svc.Status()
		payload, err := resp.Marshal()
		if err != nil {
			logs.LogWarn.Println(err)
			break
		}
		pubsub.Publish(fmt.Sprintf("%s/%s", pubsub.TopicStatus, msg.GetSender()), payload)
	case *messages.IgnitionStateRequest:
		resp, err := act.svc.Info(ctx, ctx.Parent())
		if err != nil {
			logs.LogError.Println(err)
			break
		}
		payload, err := resp.Marshal()
		if err != nil {
			logs.LogWarn.Println(err)
			break
		}
		pubsub.Publish(fmt.Sprintf("%s/%s", pubsub.TopicRequestInfoState, msg.GetSender()), payload)
	}
}
